# -*- coding: utf-8 -*-

"""
    @Author 坦克手贝塔
    @Date 2023/7/12 14:48
"""
from typing import List

"""
一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。
    比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。
一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 
[4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。 

示例 1：
输入：nums = [4,2,5,3]
输出：7
解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。

示例 2：
输入：nums = [5,6,7,8]
输出：8
解释：最优子序列为 [8] ，交替和为 8 。

示例 3：
输入：nums = [6,2,1,2,4,5]
输出：10
解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。
"""
"""
思路：我们定义 f[i] 表示从前 i 个元素中选出的子序列，且最后一个元素为奇数下标时的最大交替和，定义 g[i] 表示从前 i 个元素中选出
的子序列，且最后一个元素为偶数下标时的最大交替和。初始时 f[0]=g[0]=0。答案为 max(f[n],g[n])。我们考虑第 i 个元素 nums[i−1]：
如果选取该元素且该元素为奇数下标，那么上一个元素必须为偶数下标，且只能从前 i−1 个元素中选取，因此 f[i]=g[i−1]−nums[i−1]；如果
不选取该元素，那么 f[i]=f[i−1]。同理，如果选取该元素且该元素为偶数下标，那么上一个元素必须为奇数下标，且只能从前 i−1 个元素中
选取，因此 g[i]=f[i−1]+nums[i−1]；如果不选取该元素，那么 g[i]=g[i−1]。综上，我们可以得到状态转移方程：
f[i]=max(g[i−1]−nums[i−1],f[i−1])；g[i]=max(f[i−1]+nums[i−1],g[i−1])，最终答案为 max(f[n],g[n])。
"""


class Solution:
    @staticmethod
    def maxAlternatingSum(nums: List[int]) -> int:
        n = len(nums)
        f = [0] * (n + 1)
        g = [0] * (n + 1)
        for i, x in enumerate(nums, 1):
            f[i] = max(g[i - 1] - x, f[i - 1])
            g[i] = max(f[i - 1] + x, g[i - 1])
        return max(f[n], g[n])
