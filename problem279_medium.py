# -*- coding: utf-8 -*-

"""
    @Author 坦克手贝塔
    @Date 2022/11/15 11:10
"""
"""
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

示例 1：
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4

示例 2：
输入：n = 13
输出：2
解释：13 = 4 + 9
"""
"""
思路：
（1）dp问题，我们可以依据题目的要求写出状态表达式：f[i]表示最少需要多少个数的平方来表示整数 i。这些数必然落在区间 [1, 根号n]。
我们可以枚举这些数，假设当前枚举到 j，那么我们还需要取若干数的平方，构成 i-j^2。此时我们发现该子问题和原问题类似，只是规模变小了。
这符合了动态规划的要求，于是我们可以写出状态转移方程。
（2）四平方和定理，四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。
当 n = 4^k ×(8m+7) 时，nn 只能被表示为四个正整数的平方和。此时我们可以直接返回 4。
答案为 1 时，则必有 n 为完全平方数，这很好判断；
答案为 2 时，则有 n=a^2+b^2，我们只需要枚举所有的(1≤a≤根号n)，判断 n-a^2是否为完全平方数即可；
答案为 3 时，我们很难在一个优秀的时间复杂度内解决它，但我们只需要检查答案为 1 或 2 的两种情况，即可利用排除法确定答案。
"""


class Solution:
    @staticmethod
    def numSquares(n: int) -> int:
        # dp = [i for i in range(n+1)]
        # for i in range(1, n+1):
        #     j = 1
        #     while j*j <= i:
        #         dp[i] = min(dp[i], dp[i-j*j]+1)
        #         j += 1
        # return dp[n]

        def is_perfect(x):
            temp = int(x ** 0.5)
            return temp ** 2 == x

        def answer4(x):
            while x % 4 == 0:
                x /= 4
            return x % 8 == 7

        if is_perfect(n):
            return 1
        if answer4(n):
            return 4
        j = 1
        while j ** 2 < n:
            if is_perfect(n - j ** 2):
                return 2
            j += 1
        return 3
