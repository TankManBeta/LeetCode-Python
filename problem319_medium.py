# -*- coding: utf-8 -*-

"""
    @Author 坦克手贝塔
    @Date 2023/3/15 10:56
"""
from math import sqrt

"""
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。
直到第 n 轮，你只需要切换最后一个灯泡的开关。
找出并返回 n 轮后有多少个亮着的灯泡。

示例 1：
输入：n = 3
输出：1 
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 
你应该返回 1，因为只有一个灯泡还亮着。

示例 2：
输入：n = 0
输出：0

示例 3：
输入：n = 1
输出：1
"""
"""
思路：
（1）模拟超时
（2）经过 n 轮修改后，处于 打开状态 的灯泡个数就等于 n 个正整数(1, 2, ..., n) 中约数个数为 奇数 的正整数个数。借用大佬们根据 
约数个数定理 推导的结论：约数个数为 奇数 的正整数一定是一个完全平方数！！！接下来问题就转化为求：n 个正整数(1, 2, ..., n) 
中有多少完全平方数？那这个就简单了，int(sqrt(n))。
"""


class Solution:
    @staticmethod
    def bulbSwitch(n: int) -> int:
        # if n == 0:
        #     return 0
        # if n == 1:
        #     return 1
        # count = [1] * n
        # for i in range(2, n+1):
        #     for j in range(i-1, n, i):
        #         count[j] = 1 - count[j]
        # return sum(count)

        return int(sqrt(n))
