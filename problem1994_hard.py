# -*- coding: utf-8 -*-

"""
    @Author 坦克手贝塔
    @Date 2022/2/22 15:47
"""
"""
给你一个整数数组nums。如果nums的一个子集中，所有元素的乘积可以表示为一个或多个互不相同的质数的乘积，那么我们称它为好子集。
比方说，如果 nums = [1, 2, 3, 4] ：
    [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
    [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。
nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。
如果两个子集删除的下标不同，那么它们被视为不同的子集。

输入：nums = [1,2,3,4]
输出：6
解释：好子集为：
- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。

输入：nums = [4,2,3,15]
输出：5
解释：好子集为：
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
"""
"""
思路：状态压缩dp，1<=nums[i]<=30是个突破口，首先我们整理出1-30之间所有的素数，这些素数都最多只能出现一次，我们可以用一个10位的
二进制数表示选的状态，用mask标记num出现质数的位置，如果num=6，6=2*3，对应prime数组中的索引为0,1.所以mask=bin(11)=3，
然后通过mask来动态规划，如果i&mask==0，即没有重复值，则dp[i|mask] += dp[i]*cnt[num]
"""


class Solution(object):
    @staticmethod
    def number_of_good_subsets(nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        mod = 10 ** 9 + 7
        counter = {}
        for num in nums:
            counter[num] = counter.get(num, 0) + 1
        prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        m = len(prime)
        dp = [0] * (1 << m)
        dp[0] = 1
        for num in counter:
            if num == 1:
                continue
            if any(num % (p * p) == 0 for p in prime):
                continue
            mask = 0
            for i in range(m):
                if num % prime[i] == 0:
                    mask |= 1 << i
            for i in range(1 << m):
                if i & mask == 0:
                    dp[i | mask] += dp[i] * counter[num]
                    dp[i | mask] %= mod
        return (1 << counter.get(1, 0)) * (sum(dp) - 1) % mod
