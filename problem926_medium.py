# -*- coding: utf-8 -*-

"""
    @Author 坦克手贝塔
    @Date 2023/1/31 9:04
"""
"""
如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。
给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。
返回使 s 单调递增的最小翻转次数。

示例 1：
输入：s = "00110"
输出：1
解释：翻转最后一位得到 00111.

示例 2：
输入：s = "010110"
输出：2
解释：翻转得到 011111，或者是 000111。

示例 3：
输入：s = "00011000"
输出：2
解释：翻转得到 00000000。
"""
"""
思路：
当 i=0 时，对应长度为 1 的前缀，一定满足单调递增，因此 dp[0][0] 和 dp[0][1] 的值取决于字符 s[i]。具体而言，dp[0][0]=I(s[0]='1')，
dp[0][1]=I(s[0]='0')，其中 I 为示性函数，当事件成立时示性函数值为 1，当事件不成立时示性函数值为 0。
当 1≤i<n 时，考虑下标 i 处的字符。如果下标 i 处的字符是 0，则只有当下标 i−1 处的字符是 0 时才符合单调递增；如果下标 i 处的字符是 
1，则下标 i−1 处的字符是 0 或 1 都符合单调递增，此时为了将翻转次数最小化，应分别考虑下标 i−1 处的字符是 0 和 1 的情况下需要的
翻转次数，取两者的最小值。
在计算 dp[i][0] 和 dp[i][1] 时，还需要根据 s[i] 的值决定下标 i 处的字符是否需要翻转，因此可以得到如下状态转移方程，其中 I 为
示性函数：
    dp[i][0]=dp[i−1][0]+I(s[i]='1')
    dp[i][1]=min(dp[i−1][0],dp[i−1][1])+I(s[i]='0') 
遍历字符串 s 计算每个下标处的状态值，遍历结束之后，dp[n−1][0] 和 dp[n−1][1] 中的最小值即为使字符串 s 单调递增的最小翻转次数。
"""


class Solution:
    @staticmethod
    def minFlipsMonoIncr(s: str) -> int:
        dp0 = dp1 = 0
        for c in s:
            dp0New, dp1New = dp0, min(dp0, dp1)
            if c == '1':
                dp0New += 1
            else:
                dp1New += 1
            dp0, dp1 = dp0New, dp1New
        return min(dp0, dp1)