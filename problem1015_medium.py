# -*- coding: utf-8 -*-

"""
    @Author 坦克手贝塔
    @Date 2023/5/10 11:29
"""
"""
给定正整数 k ，你需要找出可以被 k 整除的、仅包含数字 1 的最 小 正整数 n 的长度。
返回 n 的长度。如果不存在这样的 n ，就返回-1。
注意： n 不符合 64 位带符号整数。 

示例 1：
输入：k = 1
输出：1
解释：最小的答案是 n = 1，其长度为 1。

示例 2：
输入：k = 2
输出：-1
解释：不存在可被 2 整除的正整数 n 。

示例 3：
输入：k = 3
输出：3
解释：最小的答案是 n = 111，其长度为 3。
"""
"""
思路：
在模运算中，经常会用到两个等式：(a+b)%m = (a%m+b%m)%m；(a*b)%m = ((a%m)*(b%m))%m。
所以对于此问题：我们可以得到这样的等式：res_new=(n_old×10+1)%k=((n_old%k)×10+1)%k=(res_old×10+1)%k。
简单证明一下：n_old=k*m+r，n_old*10=10*k*m+10*r，所以可以写成(n_old%k)×10。
为什么循环次数是k+1次，因为根据鸽笼原理，余数范围是[0,...,k-1]，所以k+1次时必会有重复。
"""


class Solution:
    @staticmethod
    def smallestRepunitDivByK(k: int) -> int:
        n = 1 % k
        for i in range(1, k + 1):
            if n == 0:
                return i
            n = (n * 10 + 1) % k
        return -1
