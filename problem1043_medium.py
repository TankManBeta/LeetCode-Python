# -*- coding: utf-8 -*-

"""
    @Author 坦克手贝塔
    @Date 2023/4/19 10:19
"""
from typing import List

"""
给你一个整数数组 arr，请你将该数组分隔为长度 最多 为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。
返回将数组分隔变换后能够得到的元素最大和。本题所用到的测试用例会确保答案是一个 32 位整数。 

示例 1：
输入：arr = [1,15,7,9,2,5,10], k = 3
输出：84
解释：数组变为 [15,15,15,9,10,10,10]

示例 2：
输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
输出：83

示例 3：
输入：arr = [1], k = 1
输出：1
"""
"""
思路：题目的意思是把arr切成若干个子数组，然后每个子数组的长度不超过k，然后对于每个子数组来说，用这个子数组中的最大值来代替子数组
中的所有元素，然后返回新的arr的和。因此我们可以使用动态规划，我们定义 f[i] 表示将数组的前 i 个元素分隔成若干个子数组，最终的
最大元素和。初始时 f[i]=0，答案为 f[n]。对于 f[i]，它的最后一个元素是 arr[i−1]。由于每个子数组的长度最多为 k，并且我们需要求得
子数组中的最大值，因此，我们可以从右往左枚举最后一个子数组的第一个元素 arr[j−1]，其中 max(0,i−k)<j≤i，过程中维护一个变量 mx，
表示最后一个子数组中的最大值，那么状态转移方程为：f[i]=max{f[i],f[j−1]+mx×(i−j+1)}
"""


class Solution:
    @staticmethod
    def maxSumAfterPartitioning(arr: List[int], k: int) -> int:
        n = len(arr)
        f = [0] * (n + 1)
        for i in range(1, n + 1):
            mx = 0
            for j in range(i, max(0, i - k), -1):
                mx = max(mx, arr[j - 1])
                f[i] = max(f[i], f[j - 1] + mx * (i - j + 1))
        return f[n]
